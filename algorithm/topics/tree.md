--**来源：《数据结构（韩桂华 程桂卿主编）》**--

# 树（Tree）

## 引言

`树`是以`分组`关系定义的`层次结构`，其中以`二叉树`最为常用。

## 树的定义和术语

### 定义

树是n（n≥0）个`有限`数据元素的`集合`。在任意一棵`非空`树T中，有以下一些特点。

（1）`有且仅有一个`特定的称为`树根（root）`的结点（`根结点`无前驱结点）。

（2）当n>1时，除根结点之外的其余结点被分成m（m>0）个`互不相交`的集合T1,T2,...,Tm。其中，每一个集合Ti（1≤i≤m）本身又是一棵树，并且称为`根`的`子树`。

树的定义采用了`递归`定义的方法，即在树的定义中又用到树的概念，这正好反映了树的固有特性。

### 基本术语

树的基本术语主要有下列几种。

（1）`结点：`树的结点包含一个数据元素及若干指向其子树的分支。

（2）`结点的度：`结点所拥有的子树数称为该结点的度（degree）。

（3）`树的度：`树中各结点度的最大值称为该树的度。

（4）`叶子（终端结点）：`度为零的结点叶子结点。

（5）`分支结点：`度不为零的结点称为分支结点。

（6）`兄弟结点：`同一父亲结点下的结点称为兄弟结点。

（7）`层数：`树的根结点的层数为1,其余结点的层数等于它双亲结点的层数加1。

（8）`树的深度：`树中结点的最大层数称为树的深度（或高度）。

（9）`森林：`零棵或有限棵互不相交的树的集合称为森林。在数据结构中，树和森林并不像在自然界中那样有一个明显的量的差别。任何一棵树，只要删去根结点就成了森林。

（10）`有序树和无序树：`如果树中结点的各子树`从左到右`是有次序的（即不能互换），则称这样的树为有序树；否则，称为无序树。

## 二叉树

在`有序树`中有一类最特殊，也是最重要的树，称为`二叉树（binary tree）`。二叉树是树结构中最简单的一种，但却有着十分广泛的应用。

### 二叉树的定义

#### 定义

二叉树是有n（n≥0）个结点的`有限集合`，它有如下一些特点。

（1）该集合可以为空（n=0）。

（2）该集合可以由一个根结点及两个不相交的子树组成非空树，这两个子树分别称为`左子树`和`右子树`。

（3）左子树和右子树同样又都是二叉树。

在一棵`非空二叉树`中，每个结点`至多`有两颗子树，分别称为左子树和右子树，并且`左、右子树的次序不能任意交换`。因此，`二叉树`是特殊的`有序树`。

#### 二叉树的形态

根据定义，二叉树可以有5种基本形态：（a）空二叉树；（b）仅有根结点的二叉树；（c）右子树为空的二叉树；（d）左子树为空的二叉树；（e）左、右子树均非空的二叉树。

#### 二叉树的基本操作

二叉树的基本操作通常有以下几种。

（1）创建一棵二叉树。

（2）显示二叉树。

（3）按`先序（根、左、右）遍历`二叉树上所有结点。

（4）按`中序（左、根、右）遍历`二叉树上所有结点。

（5）按`后序（左、右、根）遍历`二叉树上所有结点。

（6）按`层次`遍历二叉树上所有结点。

（7）求二叉树叶子结点总数。

（8）求二叉树的深度。


### 二叉树的性质

#### 性质1

一棵`非空二叉树`的第i层上最多2^(i-1)个结点（i≥0）。

一棵非空二叉树的第一层有1个结点，第二层最多有2个结点，第三层最多有4个结点，以此类推，利用归纳法即可证明第i层上最多有2^(i-1)个结点。

#### 性质2

深度为h的二叉树中，最多具有2^h-1个结点（h≥1）。

**满二叉树：**

一棵深度为h，且有2^h-1个结点的二叉树称为`满二叉树`。

**完全二叉树：**

深度为h，有n个结点的二叉树，当且仅当其每个结点的编号都与深度为h的`满二叉树`中从1至n的结点的编号一一对应时，称此二叉树为`完全二叉树`。

`完全二叉树`除了最后一层外，其余各层都是满的，并且最后一层或者为满，或者仅在右边缺少连续的若干个结点。

#### 性质3

对于一棵有n个结点的`完全二叉树`，若按`满二叉树`的方法对结点进行编号，则对于任意序号为i的结点，有以下性质。

（1）若i=1,则序号为i的结点是根结点；若i>1，则序号为i的结点的父结点的需要为i/2。

（2）若2i≤n，则序号为i的结点的左孩子结点的序号为2i；若2i>n，则序号为i的结点无左孩子。

（3）若2i+1≤n，则序号为i的结点的右孩子结点的序号为2i+1；若2i+1>n，则序号为i的结点无右孩子。

#### 性质4

具有n（n>0）个结点的`完全二叉树（包括满二叉树）`的深度（h）为`└log2n」+1`。

注：`└log2n」`表示不大于`log2n`的最大整数，`「log2n┐`表示不小于`log2n`的最小整数。例如，当n=10时，`└log2n」=3`，`「log2n┐=4`。

#### 性质5

对于一棵非空的二叉树，设n0、n1、n2分别表示`度`为0、1、2的结点个数，则有n0=n2+1。

### 二叉树的存储

二叉树的存储结构也分为`顺序存储`和`链接存储`两种存储结构。

#### 顺序存储结构

二叉树的顺序存储，就是用`一组连续的存储单元`存放二叉树中的结点。一般可以采用`一维数组`或`二维数组`的方法进行存储。

**一维数组存储法：**

`二叉树中各结点的编号`与`等深度的完全二叉树中对应位置上结点的编号`相同。其编号过程为：首先把`根结点`的编号定为1,然后按照层次`从上至下、从左到右`的顺序，对每一个结点进行编号。当`双亲结点`为i时，其`左孩子`的编号为2i，其`右孩子`的编号为2i+1。

对于`一般的二叉树`，如果按从上至下和从左到右的顺序将树中的结点顺序存储在`一维数组`中，则数组元素下标之间的关系不能够反映二叉树中结点之间的逻辑关系，只有增加一些`并不存在的空结点`，使之成为一棵`完全二叉树`的形式，才能用`一维数组`进行存储。显然，这种存储结构造成大量的空间浪费。

对于`完全二叉树`和`满二叉树`，这种顺序存储结构既`能够最大限度地节省存储空间，`又可以利用`数组元素的下标值`确定`结点在二叉树中的位置`，因为`完全二叉树`上编号为`i的结点`元素存储在`一维数组`中下标为`i-1的分量`中。

**静态链表存储法：**

用`数组`描述的`链表`，称为`静态链表`。`静态链表`这种存储结构与`顺序表`一样，需要预先为其分配一个较大的数组空间，但与顺序表不同的是，静态链表在插入和删除操作时不需移动元素，仅需修改指针的指向关系即可，故仍具有链式存储结构的主要优点。

静态链表除了可以用来描述线性结构之外，也可以用来存储二叉树这种非线性结构。静态链表的二叉树结点结构可以定义如下：

```go

type StaticLinkListNode struct {
    data interface{}
    lChild int
    rChild int
}

type StaticLinkList struct {
    list []StaticLinkListNode
    root int
}

```

设二叉树的结点树为n，则静态链表的`预设长度MAXLEN`≥n。

顺序存储结构小结：

（1） 当二叉树为`满二叉树`或`完全二叉树`时，采用`一维数组`存储可以节省存储空间。

（2）当二叉树`层数高而结点较少`时，采用`静态链表`存储比较好，并且这种结构`插入或删除结点时`均不需要移动任何结点，比较方便。

（3）`一维数组`存储的`优点是查找父子结点的位置非常方便`，其`缺点是进行插入或删除操作要进行大量的数据移动`。

（4）`静态链表`存储结构便于在`没有指针类型的高级程序设计语言`中使用链表结构。

（5）`顺序存储的这两种实现方式`的`共同缺点是均需要预设结点存储空间，并且存储空间的扩充不太方便`。

#### 链式存储结构

二叉树的链式存储结构是用链表来表示二叉树，即用链指针来指示结点的逻辑关系。通常有下面两种形式。

**二叉链表存储：**

`二叉链表结点`由`一个数据域`和`两个指针域`组成。其中，`数据域`用于存储结点的数据信息；`左指针域`用于存储该结点`左子树根结点的地址`；`右指针域`用于存储该结点`右子树根结点的地址`；当左子树或右子树不存在时，相应的指针域值为空。

容易证明，在含有n个结点的二叉链表中有n+1个`空指针域`。利用这些`空指针域`存储其他有用信息，从而可以得到另外一种存储结构--`线索化链表`。

二叉树的`二叉链表`可以定义如下：

```go

type node struct {
    data interface{}
    lNode *node
    rNode *node
}

type List struct {
    root *node
    len int
}

```

**三叉链表存储：**

`三叉链表结点`由`一个数据域`和`三个指针域`组成；`数据域`用于存放结点的数据信息；`左指针域`用于存放该结点`左子树根结点的地址`；`右指针域`用于存放该结点的`右子树根结点的地址`；`父指针域`用于存放该结点的`父结点的存储地址`。

这种存储结构既便于查找左、右子树中的结点，又便于查找父结点及其祖先结点，但付出的代价是增加了存储空间的开销。

### 遍历二叉树和线索二叉树

#### 遍历二叉树

`二叉树的遍历`是指`按某种顺序`访问二叉树中的所有结点，使得`每个结点都被访问，并且仅被访问一次`。通过一次遍历，使二叉树中结点的`非线性序列`转变为`线性序列`。也就是说，使遍历的结点序列之间产生一对一的关系。

由`二叉树的递归定义`可知，一棵二叉树由`根结点（D）`、`根结点的左子树（L）`和`根结点的右子树（R）`三部分组成。因此，只要依次遍历这三个部分，就可以遍历整个二叉树。若以D、L、R分别表示访问根结点、遍历根结点的左子树、遍历根结点的右子树，则二叉树的遍历方式有6种不同的组合，即DLR、LDR、LRD、DRL、RDL和RLD。如果限定先左后右的次序，那么，就只有DLR、LDR和LRD三种遍历方式。

**1、先序遍历**

先序遍历（DLR）也称为先根遍历，其递归过程如下。

若二叉树为空，则遍历结束。否则，按以下顺序遍历：访问根结点；先序遍历根结点的左子树；先序遍历根结点的右子树。

先序遍历的递归算法如下：

```go

// 先序遍历二叉树BT
func PreOrder(bt *BT) {
    // 树不为空才能访问其结点
    if bt != nil {
        fmt.Print(bt.data)  // 输出结点的数据域

        PreOrder(bt.lChild) // 先序递归遍历左子树
        PreOrder(bt.rChild) // 先序递归遍历右子树
    }
}

```

**2、中序遍历**

中序遍历（LDR）也称为中根遍历，其递归过程如下。

若二叉树为空，则遍历结束。否则，按以下顺序遍历：中序遍历根结点的左子树；访问根结点；中序遍历根结点的右子树。

中序遍历递归算法如下。

```go

// 中序遍历二叉树BT
func InOrder(bt *BT) {
    // 树不为空才能访问其结点
    if bt != nil {
        InOrder(bt.lChild)  // 中序遍历左子树

        fmt.Print(bt.data)  // 输出结点的数据域

        InOrder(bt.rChild)  // 中序遍历右子树

    }
}

```

**3、后序遍历**

后序遍历（LRD）也称为后根遍历，其递归过程如下。

若二叉树为空，则遍历结束。否则，按以下顺序遍历：后序遍历根结点的左子树；后序遍历根结点的右子树；访问根结点。

后序遍历递归算法如下。

```go

// 后序遍历二叉树BT
func PostOrder(bt *BT) {
    // 树不为空才能访问其结点
    if bt != nil {
        PostOrder(bt.lChild)    // 后序遍历左子树
        PostOrder(bt.rChild)    // 后序遍历右子树
        fmt.Print(bt.data)      // 输出结点的数据域
    }
}

```

**4、层次遍历**

按照自上而下（从根结点开始），从左到右（同一层）的顺序逐层访问二叉树上的所有结点，这样的遍历称为按层次遍历。

按层次进行遍历时，当一层结点访问完后，接着访问下一层的结点，先遇到的结点先访问，这与队列的操作原则是一致的。因此，在进行层次遍历时，可设置一个数组来模拟队列，用于保存被访问结点的子结点的地址。遍历从二叉树的根结点开始，首先将根结点指针入队列，然后从队头取出一个元素，每取一个元素，则执行下面的两个操作。

（1）访问该元素所指结点。

（2）若该元素所指结点的左、右孩子结点非空，则将该元素所指结点的左孩子指针和右孩子指针一次入队。

此过程不断进行，直到队空为止。

在下面的层次遍历算法中，二叉树以二叉链表方式存储，一维数组`[MAXLEN]*BT{}`用于实现队列，`lChild`和`rChild`分别是被访问结点的左、右指针。层次遍历算法如下。

```go

// 按层次遍历二叉树BT
func LevelOrder(bt *BT) {
    var i, j int    // i指示队头元素的下标，j指示队尾后面的空单元
    var q [MAXLEN]*BT   // 设置一个数组来模拟队列

    // 若二叉树非空，则根结点地址入队
    if bt != nil {
        q[i] = bt
        j ++
    }
    // i!=j时表示队列不为空
    for ;i != j; {
        p := q[i]
        i ++                        // 出队一个元素
        fmt.Print(p.data)           // 访问出队元素结点的数据域
        if p.lChild != nil {        // 将出队元素结点的左孩子结点入队列
            q[j] = p.lChild
            j ++
        }
        if p.rChild != nil {        // 将出队元素结点的右孩子结点入队列
            q[j] = p.rChild
            j ++
        }
    }
}

```

#### 恢复二叉树

任意一棵二叉树结点的先序序列和中序序列都是唯一的。那么能否根据结点的先序序列和中序序列来唯一地确定一棵二叉树呢？答案是肯定的。

在统一绘图软件或其他绘图软件中存在着这样的问题：如果存储一个用树表示的图形数据结构？在研制统一绘图软件系统时是采用如下办法来处理的。

（1）对于用链表结构表示的图形数据结构，去掉每一个结点的指针项，只按结点的中序序列存储，并给出这棵树的前序（或后序）`序表`。

（2）图形结构调入内存时，由中序的结点表及`序表`形成的前序和中序数组（或后序和中序数组），来恢复图形数据结构。

二叉树的先序遍历是先访问根结点，然后再遍历根结点的左子树，最后遍历根结点的右子树。即在先序序列中，第一个结点必定是二叉树的根结点。

中序遍历则是先遍历左子树，然后访问根结点，最后再遍历右子树。这样根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列则是根结点的右子树的中序序列。

根据这两个子序列，先由先序序列确定第一个结点为根结点；知道根结点后，按中序序列可以划分左、右子树。在先序序列中，左子树序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。这样，就确定了二叉树的3个结点。同时，左子树和右子树的根结点又可以分别把左子序列和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以恢复一棵二叉树。

#### 线索二叉树

##### 什么是线索二叉树

遍历二叉树是按一定的规则将二叉树中所有结点排列为一个有序序列，这实质上是对一个`非线性的数据结构进行线性化`的操作。经过遍历的结点序列，除第一个结点和最后一个结点以外，其余每个结点都有且仅有一个直接前驱结点和一个直接后继结点。

当以二叉`链表`作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点任意一个序列中的`直接前驱结点`和`直接后继结点`是什么，这种信息只有在对二叉树遍历的动态过程中才能得到。若增加`前驱指针`和`后继指针`将使存储密度进一步降低。

在用二叉`链表`存储的二叉树中，单个结点的二叉树有两个`空指针域`；两个结点的二叉树有三个`空指针域`。

不难证明：`n`个结点的二叉树有`n+1`个空指针域。也就是说，一个具有`n`个结点的二叉树，若采用二叉`链表`存储结构，在其总共`2n`个指针域中只有`n-1`个指针域是用于存储结点子树的地址，而另外`n+1`个指针域存放的都是`空指针域`。因此，可以充分利用`二叉链表`存储结构中的那些`空指针域`，来保存结点在某种遍历序列中的`直接前驱结点`和`直接后继结点`的地址信息。

指向直接前驱结点或指向直接后继结点的指针称为`线索（thread）`，带有线索的二叉树称为`线索二叉树`。对于二叉树以某种次序遍历使其变为线索二叉树的过程称为`线索化`。

##### 线索二叉树的方法

由于二叉树结点的序列可由不同的遍历方法得到，因此，线索二叉树也分为`先序线索二叉树`、`中序线索二叉树`和`后序线索二叉树`三种。在三种线索二叉树中一般以`中序线索化`用得最多。

线索二叉树的结点结构定义如下。

```go

type ThreadBinaryNode struct {
    data interface{}            // 二叉链表的结点数据
    lTag bool                   // 左孩子标志，当lTag为true时，表示左孩子存在（lChild所指为该结点左孩子）；反之，则表示左孩子不存在（lChild所指为该结点直接后继结点）
    lChild *ThreadBinaryNode    // 左孩子指针
    rTag bool                   // 其含义与lTag类似
    rChild *ThreadBinaryNode    // 右孩子指针
}

```

二叉树进行中序线索化的递归函数代码如下。

```go

func InThreadBinaryTree(t *ThreadBinaryNode, pre *ThreadBinaryNode, rear *ThreadBinaryNode) {
    // pre指向整个二叉树t中序序列的直接前驱结点
    // rear指向整个二叉树t中序序列的直接后继结点
    if t.lTag {
        // 左子树的直接前驱结点就是整棵二叉树的直接前驱结点，左子树的直接后继结点就是整棵二叉树的根结点
        InThreadBinaryTree(t.lChild, pre, t)
    } else {
        t.lChild = pre
    }

    if t.rTag {
        // 右子树的直接前驱结点就是整棵二叉树的根结点，右子树的直接后继结点就是整棵二叉树的直接后继结点
        InThreadBinaryTree(t.rChild, t, rear)
    } else {
        t.rChild = rear
    }

}

```

由于整棵二叉树中序序列的直接前驱结点和直接后继结点均可为空，因此对二叉树`t`进行中序线索化可采用语句`InThreadBinaryTree(t, nil, nil)`。

另外，为了便于操作，在存储线索二叉树时需要`增设`一个结点，其结构与其他线索二叉树的结点结构一样。但是，`头结点`的`数据域`不存放信息，它的`左指针域`指向二叉树的`根结点`，`右指针域`指向自己。而原二叉树在某种序列遍历下的`第一个结点的前驱线索`和`最后一个结点的后继线索`都指向`头结点`。

##### 线索二叉树的优点

（1）利用`线索二叉树`进行`中序遍历`时，不必采用`堆栈`处理，速度比一般二叉树的遍历速度快，并且节约存储空间。

（2）任意一个结点都能直接找到它相应遍历顺序的直接前驱结点和直接后继结点。

##### 线索二叉树的缺点

（1）结点的插入和删除较麻烦，并且速度也比较慢。

（2）线索子树不能共用。

### 二叉树的转换

如果对`树`或`森林`采用`链表存储并设定一定的规则`，就可以用`二叉树结构`表示树和森林。这样，对树的操作实现就可以借助二叉树存储，利用二叉树上的操作实现。本节将讨论树和森林与二叉树之间的转换方法。

#### 树的存储结构

在实际应用中，很多事物是不能直接用二叉树来描述的，而只能用树和森林来表示。

**1、双亲表示法**

`双亲表示法`是用一组连续的空间来存储树上的结点，同时在每个结点上附加一个指示器来指明其双亲结点所在的位置。

```go

type PTNode struct {
    data interface{}
    parent int
}

type PTree struct {
    nodes [MAX_TREE_SIZE]*PTNode
    n int
}

```

在这种表中，每个结点（除根结点外）有且仅有一个双亲结点，通过`parent域`很容易找到任何结点的双亲。但是，在查找孩子结点时则需要遍历整个表。为了使查找孩子结点更方便些，可以采用下面的存储结构。

**2、孩子链表表示法**

`孩子链表表示法`也是用`一组连续的空间`来存储树上的结点，同时在每个结点上附加一个指针指向由其`孩子结点构成的单链表`。其类型定义如下。

```go

type CTNode struct {
    child int
    next *CTNode
}

type CTBox struct {
    data interface{}
    firstChild *CTNode
}

type CTree struct {
    nodes [MAX_TREE_SIZE]*CTBox
    n int
}

```

在这种表示法中，找孩子结点比较容易，只要搜索`firstChild`指针指向的`单链表`即可。但要找某一结点的双亲结点就比较困难了，需要搜索所有的单链表。为了克服上述两种表示法的弊端，可以将两种表示法综合起来使用。

**3、孩子双亲表示法**

`孩子双亲表示法`也是用`一组连续的空间`来存储树上的结点，同时在每个结点上附加一个`指示器`来指示其双亲结点的位置，再附加一个指针指向其孩子结点构成的单链表。其类型定义如下。

```go

type CTNode struct {
    child int
    next *CTNode
}

type PCNode struct {
    data interface{}
    parent int
    firstChild *CTNode
}

type PCTree struct {
    nodes [MAX_TREE_SIZE]*PCNode
    n int
}

```

在这种表示法中，既能很快地找到每个结点的双亲结点，又能很快地找到每个结点的孩子结点。但这种方法是`用空间的代价换来的时间效率`，在具体应用中一定要根据不同的情况去选择较为合适的存储结构。

以上三种都是用`顺序表`的形式来表示`树`和`森林`，这很难转换成`二叉树的存储形式`，也就不能用二叉树中理论和结构来描述树和森林。

**4、孩子兄弟表示法**

`孩子兄弟表示法`是以`二叉链表`作为存储结构来表示树和森林的一种结构，其中每个结点的两个指针分别指向其`第一个孩子结点`和`下一个兄弟结点`。其类型定义如下。

```go

type CSNode struct {
    data interface{}
    firstChild *CSNode
    nextSibling *CSNode
}

```

这种结构有利于实现树和森林的各种操作。例如，找某个结点的第`i`个孩子结点，只要先沿着`firstChild`指针找到`第一个孩子结点`，然后再沿着该孩子结点的`nextSibling`指针走`i-1`步即可。`若每个结点增加一个双亲指针域`，则可以很快找到其双亲结点。此外，`孩子兄弟链表`实质上就是前述的`二叉链表`，只是解释不同而已，有关二叉树的大部分操作均可在这种结构上实现。因此，`孩子兄弟链表`也成为`树、森林与二叉树之间的桥梁和纽带`。

#### 一般树转换为二叉树

**1、一般树和二叉树的二叉链表存储结构比较**

`一般树`是`无序树`，树中结点的各孩子的次序是无关紧要的；`二叉树`中结点的左、右孩子结点是有区别的。为避免混淆，约定树中每一个结点的孩子结点按`从左到右`的次序排列。

**2、将一般树转换为二叉树的方法**

只要把`一般树`的`长子结点`作为其`左子树`，把其`次弟结点`作为其`右子树`，即可把一棵`一般树`转换为一棵`二叉树`。

整个转换可以分为如下三步。

（1）连线 -- 链接树中所有`相邻`的`亲兄弟结点`之间连线。

（2）删线 -- 保留`父结点`和`长子结点`的连线，打断父结点与`非长子结点`之间的连线。

（3）旋转 -- 以`根结点`为轴心，将整棵树`顺时针`旋转一定的角度，使之层次分明。

可以证明，`一般树`进行如此的转换所构成的二叉树是唯一的。

由上面的转换可以得出以下结论。

（1）在转换产生的二叉树中，`左分支上`的各结点在原来的树中是`父子关系`，而`右分支上`的各结点在原来的树中则是`兄弟关系`。

（2）由于树的`根结点无兄弟`，所以转换后的二叉树的`根结点必定无右子树`。

（3）一棵树采用`长子兄弟表示法`所建立的存储结构与它所对应的二叉树的二叉链表存储结构是完全相同的。

（4）一般树转换为二叉树以后，将使树的`深度`增加。

#### 森林转换为二叉树

`森林`是若干棵树的集合。只要将`森林`中的`每一棵树的根`视为兄弟，而每一棵树又可以用二叉树表示，这样，`森林`也就可以用二叉树来表示了。

`森林`转换为`二叉树`的方法如下。

（1）将`森林`中的`每一棵树`转换成相应的二叉树。

（2）`第一棵二叉树`保持不动，`从第二棵二叉树开始`，依次把`后一棵二叉树的根结点`作为`前一棵二叉树根结点`的`右子树`，直到把最后一棵二叉树的根结点作为其前一棵二叉树的右子树为止。

#### 二叉树转换为树和森林

`树`转换为`二叉树`以后，其`根结点`必定无`右子树`；而`森林`转换为`二叉树`以后，其`根结点`有`右分支`。显然这一转换过程是`可逆的`，即可以`依据二叉树的根结点有无右子树`，将一棵二叉树还原为树或森林。转换方法如下。

（1）若某结点是其`父结点`的`左孩子结点`，则把该结点的`右孩子结点`、右孩子结点的右孩子结点，直到最后一个右孩子结点都与该结点的父结点连起来。

（2）删除原二叉树中所有的父结点与右孩子结点的连线。

（3）整理（1）、（2）的结果，使之层次分明，显示出树或森林的形状。

### 二叉树的应用

本节介绍二叉树的基本应用，包括求`二叉树的叶结点树`、`总结点数`、`二叉树的深度`等，重点介绍`标识符树`的应用。

#### 二叉树的基本应用

**1、统计二叉树叶子结点数**

（1）基本思想。若二叉树结点的左子树和右子树都为空，则该结点为叶子结点，计数器count加1；否则，依次递归统计该结点的左子树叶子结点数和该结点的右子树叶子结点数。

（2）具体算法如下。

```go

// 求二叉树的叶子结点数
func LeafNum(bt *BT) {
    // 若二叉树不为空
    if bt != nil {
        // 统计叶子结点个数
        if bt.lChild == nil && bt.rChild == nil {
            count ++
        }
        // 递归统计左子树的叶子结点数
        LeafNum(bt.lChild)
        // 递归统计右子树的叶子结点数
        LeafNum(bt.rChild)
    }
}

```

**2、求二叉树结点总数**

（1）基本思想。若二叉树根结点不为空，则计数器count加1，然后依次递归统计左子树结点数和右子树结点数。

（2）具体算法如下。

```go

// 求二叉树总结点数
func NodeNum(bt *BT) {
    // 如果二叉树不为空
    if bt != nil {
        count ++            // count为统计结点个数的变量，初值为0
        NodeNum(bt.lChild)  // 递归统计左子树结点数
        NodeNum(bt.rChild)  // 递归统计右子树结点数
    }
}

```

**3、求二叉树的深度**

（1）基本思想。若二叉树为空，则返回0；否则，递归统计左子树的深度，然后递归统计右子树的深度，递归结束后，返回其中较大的一个深度值。

（2）具体算法如下。

```go

// 求二叉树深度
func TreeDepth(bt *BT) int {
    var lDep, rDep int      // 定义两个整型变量，用于存放左、右子树的深度
    if bt == nil {          // 若树空则返回0
        return 0
    } else {
        lDep = TreeDepth(bt.lChild) // 递归统计左子树深度
        rDep = TreeDepth(bt.rChild) // 递归统计右子树深度
        // 若左子树深度大于右子树，返回左子树深度加1；否则，返回右子树深度加1
        if lDep > rDep {
            return lDep + 1
        } else {
            return rDep + 1
        }
    }
}

```

**4、查找数据元素**

在以`bt`为`根结点指针`的二叉树中查找数据元素`x`。查找成功时返回该结点的指针；查找失败时返回空指针。

（1）基本思想。先判断二叉树的根结点是否与`x`相等，若相等则返回，否则，分别在`bt.lChild`为根结点指针的二叉树中递归查找数据元素`x`，以及在`bt.rChild`为根结点指针的二叉树中递归查找数据元素`x`。

（2）具体算法如下。

```go

func Search(bt *BT, x interface{}) *BT {
    var p *BT
    if bt != nil {
        // 根结点即为查找结点，直接返回根。否则，分别在左右子树中查找
        if bt.Data == x {
            return bt
        }
        p = Search(bt.lChild, x)    // 在bt.lChild为根结点的二叉树中递归查找数据元素x
        if p != nil {               // 如果找到，返回找到的结点p
            return p
        } else {
            return Search(bt.rChild, x)
        }
    } else {
        return nil                  // 查找失败，返回空指针
    }
}

```

#### 标识符树与表达式

将`算术表达式`用二叉树表示，称为`标识符树`，又称为`二叉表示树`。

**1、标识符树的特点**

（1）`运算对象（标识符）`都是`叶结点`。

（2）`运算符`都是`根结点`。

**2、由表达式产生标识符树的方法**

（1）读入表达式的一部分产生相应的二叉树后，再读入运算符时，将该运算符与二叉树根结点的运算符比较优先级的高低。

- 若读入优先级高于根结点的优先级，则读入的运算符作为根的右子树，原来二叉树的右子树成为读入运算符的左子树。
- 若读入优先级等于或低于根结点的优先级，则读入运算符作为树根，而原来二叉树作为它的左子树。

（2）遇到括号时，先使括号内的表达式产生一棵二叉树，再把它的根结点连接到前面已产生的二叉树根结点的右子树上去。

（3）单目运算符`+`、`-`，加运算对象`θ`（表示正负号）。

只要将`算术表达式`用`标识符树`来表示，然后再求出它的`后序遍历的序列`，就能方便地得到`原表达式的后缀表达式`，这一结果和`利用堆栈求得的后缀表达式`的结果是完全一致的。

同样的道理，对该二叉树进行`先序遍历`和`中序遍历`，可以得到表达式的`前缀表达式`和`中缀表达式`。其中，`中缀表达式`就是通常使用的`算术表达式`，`前缀表达式`和`后缀表达式`分别称为`波兰式`和`逆波兰式`，它们在`编译程序`中有着非常重要的作用。

### 哈夫曼树及其应用

`哈夫曼（Haffman）树`是一种`带权路径长度最小的二叉树`，也称为`最优二叉树`，有着极为广泛的应用。

#### 哈夫曼树的引入

**1、常用术语**

（1）`路径长度：`从树中的一个结点到另一个结点之间的分支构成两个结点间的路径，路径上的分支数目，称为路径长度。

（2）`树的路径长度：`从树根到每个结点的路径长度之和称为树的路径长度。

（3）`结点的带权路径长度：`从该结点到树根之间的路径长度与该结点上`权`的乘积。

（4）`树的带权路径长度：`树中所有`叶子结点`的`带权路径长度`之和，称为树的带权路径长度。

（5）`最优二叉树：`带权路径长度最小的二叉树，称为最优二叉树。

**2、求树的带权路径长度**

设二叉树具有`n`个带权值的`叶结点`，那么，从`根结点`到各个`叶结点`的路径长度与相应结点权值的乘积之和称为`二叉树的带权路径长度（WPL）`。

**3、哈夫曼树的特点**

由于构成最优二叉树的方法是由D.Haffman最早提出的，所以又称为哈夫曼树。它的特点是权值越大的叶结点越靠近根结点。

在分析一些`决策判定问题`时，利用`哈夫曼树`可以获得`最佳的决策算法`。

#### 哈夫曼树的建立

**1、哈夫曼树构成的基本思想**

（1）由给定的`n`个权值`{W1, W2, ..., Wn}`构造`n`棵只有一个叶结点的二叉树，从而得到一个二叉树的集合`F={T1, T2, ..., Tn}`。

（2）在`F`中选取根结点的权值`最小`和`次小`的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和。

（3）在集合`F`中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合`F`中。

（4）重复（2）和（3）两步，直到`F`中只剩下一棵二叉树时，这棵二叉树便是所要建立的哈夫曼树。

**2、哈夫曼树的构造算法**

在构造哈夫曼树时，可以设置一个结构`数组HFMT`，用于保存哈夫曼树中各结点的信息。由二叉树的性质可知，具有`n`个叶结点的哈夫曼树共有`2n-1`个结点，所以`2n-1`即`数组HFMT`所需的存储空间，其结构形式如下。

```go

type node struct {
    weight int
    lchild int
    rchild int
    parent int
}

var HFMT []node

```

其中，`weight`域用于保存结点的权值；`lchild`和`rchild`域分别用于保存该结点的左、右孩子结点在`数组HFMT`中的下标；`parent`域用于判定一个结点是否已加入到要建立的哈夫曼树中。初始时`parent`的值为`-1`，当结点加入到树中时，该结点`parent`的值为其父结点在`数组HFMT`中的下标。

构造哈夫曼树时，首先将由`n`个字符形成的`n`个叶结点存放到`数组HFMT`的前`n`个分量中，然后根据哈夫曼方法的基本思想，不断将两个权值最小的子树合并为一个较大的子树，每次构成的新子树的根结点顺序放到`HFMT数组`中的前`n`个分量的后面。

#### 哈夫曼编码

**1、哈夫曼编码简介**

在数据通信中，经常需要将传送的文字转换成由二进制字符`0`和`1`组成的二进制代码，称之为`编码`。

如果在编码时考虑字符出现的频率，让出现频率高的字符采用尽可能短的编码，出现频率低的字符采用稍长的编码，构造一种`不等长编码`，则电文的代码就可能更短。`哈夫曼编码`是一种用于构造电文的编码总长最短的编码方案。

**2、哈夫曼编码的方法**

（1）构造哈夫曼树

设需要编码的字符集合为`{d1, d2, ..., dn}`，它们在电文中出现的次数集合为`{w1, w2, ..., wn}`，以`d1, d2, ..., dn`作为叶结点，`w1, w2, ..., wn`作为它们的权值，构造一棵哈夫曼树。

假设哈夫曼树`按数据频度的权值`从小到大，采用`顺序存储结构`存储。每次找到的权值最小值作为新生结点的左孩子结点，权值最小值作为新生结点的右孩子结点，则左孩子结点的权值加右孩子结点权值之和为根结点的权值。按构造哈夫曼树的算法继续找权值最小的结点和次小的结点，如果有若干个最小权值相同的结点，则谁存储在前面的结点，谁就是当前找到的最小值。

（2）在哈夫曼树上求叶结点的编码

规定哈夫曼树中的左分支代表`0`，右分支代表`1`，则从根结点到每个叶结点所经过的路径分支组成的`0`和`1`的序列便为该叶子结点对应字符的编码。

在`哈夫曼编码树`中，`树的带权路径长度`的含义是各个`字符的码长`与`其出现次数`的乘积之和，也就是`电文的代码总长`。`采用哈夫曼树构造的编码`是一种能使电文代码总长为`最短`的`不等长编码`。

`求哈夫曼编码`的实质就是在已建立的哈夫曼树中，`从叶结点开始，沿结点的双亲链域回退到根结点`，每回退一步，就走过了哈夫曼树的一个分支，从而得到一位哈夫曼码值。由于一个字符的哈夫曼编码是从根结点到相应叶结点所经过的路径上各分支所组成的`0`、`1`序列，因此，先得到的分支代码为所求编码的低位码，后得到的分支代码为所求编码的高位码。
