
# `fmt`包

`fmt`包实现了类似C语言`printf`和`scanf`的`格式化I/O`。格式化动作（`verb`）源自C语言但更简单。


## Printing（打印）

**一、动词（verb）:**

1、通用：

```

%v  值的默认格式表示
%+v 类似`%v`，但输出结构体时会添加字段名
%#v 值的`Go语法`表示
%T  值的类型的`Go语法`表示
%%  百分号

```

2、 布尔值：

```

%t  单词`true`或`false`

```

3、整数：

```

%b	表示为二进制
%c	该值对应的unicode码值
%d	表示为十进制
%o	表示为八进制
%O  表示为以`0o`开头的为八进制
%q	该值对应的`单引号`括起来的`Go语法`字符字面值，`必要时会采用安全的转义表示`
%x	表示为十六进制，使用`a-f`
%X	表示为十六进制，使用`A-F`
%U	表示为Unicode格式：U+1234，等价于"U+%04X"

```

4、浮点数与复数的组成：

```

%b  无小数部分的科学计数法，以2为权值的指数，与`strconv.FormatFloat`使用`b`格式的输出一样，如：-123456p-78
%e  科学计数法，如：-1234.456e+78
%E  科学计数法，如：-1234.456E+78
%f  有小数部分但无指数部分，如：123.456
%F  等价于`%f`
%g  根据实际情况采用`%e`或`%f`格式（以获得更简洁、准确的输出）
%G  根据实际情况采用`%E`或`%F`格式（以获得更简洁、准确的输出）
%x  十六进制计数法（有小数部分及以2为权值的指数部分），如：-0x1.23abcp+20
%X  大写的十六进制计数法，如：-0X1.23ABCP+20      

```

5、字符串和字节切片：

```

%s	直接输出字符串或者字节切片
%q	该值对应的`双引号`括起来的`Go语法`字符串字面值，`必要时会采用安全的转义表示`
%x	每个字节用两字符十六进制数表示（使用a-f）
%X	每个字节用两字符十六进制数表示（使用A-F）  

```

6、切片：

```

%p  以`0x`开头的、十六进制表示的、索引为0的元素的内存地址

```

7、指针：

```

%p	表示为十六进制，并加上前导的`0x`

`%b`，`%d`，`%o`，`%x`和`%X`动词也可以与指针配合使用，能准确地格式化数值就和作用于整数一样。

```

**二、动词的相关说明：**

1、`%v`格式化的默认行为如下：

```

bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p

```

2、对于复合对象，其元素会递归地使用这些动词规则，如下所示：

```

struct:             {field0 field1 ...}
array, slice:       [elem0 elem1 ...]
maps:               map[key1:value1 key2:value2 ...]
pointer to above:   &{}, &[], &map[]

```

3、`宽度`通过一个紧跟在`%`后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。`精度`通过（可选的）宽度后跟`.`号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果使用了`.`号，但其后没有跟数字，表示精度为`0`。举例如下：

```

%f:    默认宽度，默认精度
%9f    宽度9，默认精度
%.2f   默认宽度，精度2
%9.2f  宽度9，精度2
%9.f   宽度9，精度0

```

`宽度`和`精度`格式化控制的是`Unicode码值的数量`，即`文字符号（rune）的数量`（不同于`C语言的printf`中的这两个因数指的是`字节的数量`）。`宽度`和`精度`中任一个或两个都可以使用`*`号取代，这样`宽度`和`精度`的值会从下一个操作数（出现在格式化操作数之前的）获取，`这个操作数必须是int类型`。例如：

```go

fmt.Printf("%*.*f", 8, 2, 123.456789)  // 宽度为8，精度为2

```

对于大多数类型的值，`宽度`是要`输出`的`文字符号（rune）`数目的最小数量，如果必要会用`空格`填充。

但是，对于字符串、字节切片和字节数组，`精度`会限制要被格式化的`输入`长度（`不是输出`的大小）会在必要时进行截断。通常是用`文字符号（rune）`进行度量，但是当这些类型用`%x`或`%X`来格式化时，`精度`就会使用`字节（byte）`来度量。

对于浮点数，在适当情况下，`宽度`设置了字段的`最小宽度`（包含了`.`），`精度`设置了小数点后的数字数量；不同地是，`%g或%G`的`精度`会设置`有效数字`的`最大数量`（即会将尾随的`0`去除）。举例，`12.345`用`%6.3f`格式化会打印为`12.345`，但是用`%.3g`格式化会打印出`12.3`。`%e`、`%f`和`%#g`的默认精度为`6`；`%g`的默认精度为可以用来唯一标识该值的数字的最小数量。

对于复数，`宽度`和`精度`会分别应用于两个组成部分且结果会用括号`()`括起来，例如，`%f`被应用于`1.2+3.4i`会产出`(1.200000+3.400000i)`

**三、其它的标识（flag）：**

```

+   始终为数字值打印符号；保证`%q(%+q)`的纯ASCII输出
-   在右边而不是左边填充空格（左对齐字段）
＃   备用格式：为二进制(`%#b`)添加前导`0b`，为八进制(`%#o`)添加`0`，为十六进制(`%#x`或`%#X`)添加`0x`或`0X`；为`%p`废止`0x`；对于`%q`，如果使用`strconv.CanBackquote`返回`true`，则打印一个`原始的字符串（带反引号的）`；始终为`%e`，`%E`，`%f`，`%F`，`%g`和`%G`打印小数点；不会删除`%g`和`%G`的尾随零；如果字符可用于`%U`(`%#U`)的打印，那么会打印例如`U+0078 'x'`的输出。
' ' 空格，在数字（`% d`）里给省略号留空格；在用十六进制打印的字符串或切片的字节之间放置空格（`% x`，`%X`）
0   填充前导零而不是空格；对于数字，会转而在`符号位`后进行填充

```

`标识`会被不需要它们的`动词`忽略。例如，没有其他的十进制格式了，所以`%#d`和`%d`的行为是相同的。

对每一个`类似Printf的函数`，都有对应的`不接受格式字符串`的`Print型函数`，其效果上等价于对每一个操作数都是用动词`%v`。另一个变体`Println型函数`会在各个操作数的输出之间加空格并在最后换行。

**四、接口值的格式化：**

不管动词如何，如果操作数是一个接口值，那么会使用接口内部具体的值，而不是接口，因此：

```go

var i interface{} = 23
fmt.Printf("%v\n", i)

```

上例将会输出23。

除了使用动词`%T`和`%p`进行打印之外，有特殊的格式化注意事项应用于`实现了某些接口的`操作数；应用的顺序如下：

1、如果操作数是`reflect.Value`，则将操作数替换为其所持有的具体值，然后使用下一个规则继续打印。

2.如果一个操作数实现了`Formatter`接口，它将被调用。 `Formatter`提供了对格式化的精细控制。

3.如果`%v`动词使用了`#`标识（即`%#v`），并且操作数实现`GoStringer`接口，则将调用该接口。

如果格式（隐含地`%v`对于`Println`等）对字符串（`%s``%q``%v``%x``%X`）有效，则应用以下两个规则：

4.如果操作数实现`error`接口，则将调用`Error方法`将对象转换为字符串，然后将根据动词（如果有）的要求对其进行格式化。

5.如果操作数实现`String()`字符串方法，则调用该方法会将对象转换为字符串，然后将根据动词（如果有）的要求对其进行格式化。

`对于切片和结构体之类的复合操作数`，格式会递归地应用于每个操作数的元素，而不是整个操作数。因此`%q`会将字符串切片中的每个元素用引号括起来，而`%6.2f`将控制浮点数数组中每个元素的格式。

但是，在使用类字符串动词（`%s``%q``%x``%X`）打印一个`字节切片`时，该`字节切片`将被等同于一个字符串来处理，作为一个单项。

在如下的情况下，`要避免递归循环`：

```go

type X string
func (x X) String() string { return Sprintf("<%s>", x) }

```

在递归循环之前要将值转换一下：

```go

func (x X) String() string { return Sprintf("<%s>", string(x)) }

```

`无限递归循环`也可能由`自引用数据结构`触发，例如包含自身作为元素的切片（如果该类型具有`String方法`）；这种病理情况很少见，但是`fmt`包无法防止它们。

打印结构体时，`fmt`包无法且因此不会在`未导出的字段`上调用诸如`Error`或`String`之类的格式化方法。


**五、显式参数索引：**

在`Printf`，`Sprintf`和`Fprintf`中，默认行为是，每个格式化动词会依次格式化在调用中传递的参数。但是，紧靠动词之前的符号`[n]`，表示将格式化第`n`个参数（索引从`1`开始）。`宽度`或`精度`的`*`符号之前的`[n]`符号会表示要选用第`n`个参数值（必须是int类型）。在处理了带括号的表达式`[n]`后，除非另外指出，否则后续动词将使用自变量`n+1`，`n+2`等。

例如：

```go

fmt.Sprintf("%[2]d %[1]d\n", 11, 22)

```

将会输出`"22 11"`，而：

```go

fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6)

```

等同于：

```go

fmt.Sprintf("%6.2f", 12.0)

```

将会输出`"12.00"`。因为一个显式的索引影响了后续的动词，该记号可以被用来多次打印相同的词，通过重置第一个被重复的参数的索引：

```go

fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)

```

将会输出`"16 17 0x10 0x11"`

**六、格式化出错：**

如果给动词给定了无效的参数，比如给`%d`提供了字符串，那么生成的字符串将包含该问题的描述，如下示例：

```

Wrong type or unknown verb: %!verb(type=value)
	Printf("%d", "hi"):        %!d(string=hi)
Too many arguments: %!(EXTRA type=value)
	Printf("hi", "guys"):      hi%!(EXTRA string=guys)
Too few arguments: %!verb(MISSING)
	Printf("hi%d"):            hi%!d(MISSING)
Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)
	Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
	Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
Invalid or invalid use of argument index: %!(BADINDEX)
	Printf("%*[2]d", 7):       %!d(BADINDEX)
	Printf("%.[2]d", 7):       %!d(BADINDEX)

```

所有的报错均以字符串`%!`开头，有时后面跟一个字符（动词），以及用括号括起来的描述。

如果`Error或String方法`在由`打印例程`调用时触发了宕机（`panic`），则`fmt`包会重新格式化来自宕机（`panic`）的报错消息，修饰它并指明其是来自`fmt`软件包。例如，如果`String方法`调用`panic("bad")`，则生成的格式化消息将会如下所示：

```

%!s(PANIC=bad)

```

`%!s`仅显示发生故障时正在使用的打印动词。但是，如果宕机（`panic`）是由`Error或String方法`的`接收者为空`导致的，则输出为未经修饰的字符串`"<nil>"`。


## Scanning（扫描）

一组类似的`scan函数`会扫描`已格式化的文本`来产出`值`。`Scan`，`Scanf`和`Scanln`会从`os.Stdin`读取文本；`Fscan`，`Fscanf`和`Fscanln`会从指定的`io.Reader`读取文本；`Sscan`，`Sscanf`和`Sscanln`会从`参数字符串`读取文本。

`Scan`，`Fscan`，`Sscan`会将输入中的`换行符`视为`空格`。

`Scanln`，`Fscanln`和`Sscanln`会在`换行符`处停止扫描，并要求在被扫描项之后加上`换行符`或`EOF`。

`Scanf`，`Fscanf`和`Sscanf`根据`类似于Printf的格式字符串`解析参数。在随后的文章内容里，`空格`表示`除换行符外`的`任何Unicode空格字符`。

在格式字符串中，由`%`字符引入的动词会消耗并解析输入；这些动词将在之后进行更详细地描述。格式字符串中除`%`，`空格`或`换行符`以外的其他字符会精确地消耗输入字符，输入字符必须存在。（1）格式字符串中`换行符之前的零个或多个空格`会消耗输入中零个或多个空格，后跟一个换行符或输入结尾。（2）格式字符串中`换行符后的一个空格`会消耗输入中零个或多个空格。（3）其它的，格式字符串中任何一个或多个空格的运行都会消耗输入中尽可能多的空格。除非是处理格式字符串中与换行符相邻的空格，否则处理空格时必须消耗输入中至少一个空格或找到输入的结尾。

`空格`和`换行`的处理与`C语言的scanf系列`的处理不同：在C语言中，`换行`会与任何其他的空格一样对待，并且当格式字符串中的空格处理时，在输入中找不到要使用的空格时不会报错。

（扫描用到的）动词的行为类似于`Printf`中动词的行为。例如，`%x`将扫描一个整数作为十六进制数，`%v`将扫描默认表示形式的值。`Printf`的动词`%p`和`%T`以及标识`#`和`+`没有被实现。对于浮点和复数值，所有有效的格式化动词（`%b``%e``%E``%f``%F``%g``%G``%x``%X`和`%v`）都是等效的，并且接受十进制和十六进制表示法（例如：`2.3e+7`，`0x4.5p-8`）和分隔数字的下划线（例如：`3.14159_26535_89793`）。

被动词处理的输入是隐式用空格分隔的：除`%c`外的每个动词的实现都从丢弃其余输入中的前导空格后开始，并且`%s`动词（和`%v`读入字符串）会在第一个空格或换行符处停止消耗输入。

当没有格式字符或使用`%v`动词扫描整数时，可以接受熟悉的基本设置前缀`0b`（二进制），`0o`和`0`（八进制）和`0x`（十六进制），分隔字符的下划线也是如此。

`宽度`会在输入文本中被解释，但是没有用于`精度`扫描的语法（如没有`%5.2f`，只有`%5f`）。如果提供了`宽度`，它将`在修剪前导空格后`应用，并指明满足动词的要读取的文字符号的最大数量。例如：

```go

Sscanf("  1234567 ", "%5s%d", &s, &i)

```

将`s`设置为`"12345"`，将`i`设置为`67`，而：

```go

Sscanf(" 12 34 567 ", "%5s%d", &s, &i)

```

将`s`设置为`"12"`，将`i`设置为`34`。

在所有扫描函数中，`回车符后紧跟换行符`被视为普通换行符（即`\r\n`表示与`\n`相同）。

在所有扫描函数中，如果`操作数`实现了`Scan方法`（即实现了`Scanner接口`），则该方法将用于扫描该操作数的文本。另外，如果扫描的参数数量小于提供的参数数量，则会返回一个错误。

所有要扫描的参数都必须要么指向基础类型的指针，要么是`Scanner接口`的实现。

像`Scanf`和`Fscanf`一样，`Sscanf`不需要消耗其全部输入。无法恢复`Sscanf`使用了多少的输入字符串。

**注意：** `Fscan`等可以读取返回的输入后的一个字符（`rune`），这意味着调用扫描例程的循环可能会跳过某些输入。仅当输入值之间没有空格时，这通常是一个问题。如果提供给`Fscan`的读取器实现了`ReadRune`，则该方法将用于读取字符。如果读取器还实现了`UnreadRune`，则将使用该方法保存字符，并且后续调用不会丢失数据。要将`ReadRune`和`UnreadRune`方法附加到没有该功能的读取器，请使用`bufio.NewReader`。
