
# 信号处理


## 概述

`信号`是一种`软中断`。它提供了一种通知进程某个事件发生的机制，是最简单的进程间通信的方式。它让一个进程被另一个进程（或内核）`异步地`中断处理某个事件，处理结束后，被中断的进程从中断点重新执行。`信号机制`是系统中关于信号`产生`、`传送`和`处理`的一套机构。

`信号机制`最早在`Unix SYSTEMV`中出现，它是不可靠的。`Unix BAD4.2`改善了`SYSTEMV`的信号机制，但与`SYSTEMV`的信号机制不兼容。以后，在它们各自派生出的各种UNIX系统中，这种不兼容性延续了下来。

为了给程序员提供一个一致的编程接口，`POSIX1003.1标准【IEEE90】`制定了一个规范，定义了一个`标准的信号接口`，所有UNIX版本的信号机制都必须支持该接口。Linux的信号机制也同样支持该接口。

在一个`信号的生命过程`中有`两个`阶段：`生成`和`传送`。当事件发生时，如果需要通知某个进程，内核就会产生一个信号。而当该进程发现信号到来，就以`预先定义好的方式`来处理信号（执行信号处理函数）。在`信号产生`和`对它进行处理`之间，`信号被"挂起"（pending）`。需要注意的是，信号`必需`有其`目的进程`，即它`必需`被发送给一个进程。

当出现下面几种情况时，可以产生信号。

（1）异常。当一个进程出现异常（如试图执行非法指令），内核通过向进程发送一个消息通知该事件的发生。

（2）用户用某些键（如`Ctrl+c`、`Ctrl+d`）对终端的控制。

（3）用户态进程之间的通信。用户可以使用`kill`命令向进程发信号，进程可以通过`kill`系统调用向另一进程发信号。

（4）进程等待的某个事件的发生，如I/O设备的就绪。

（5）进程可以调用某些函数向自己发送信号。如`abort`函数向它的调用者发送`SIGABRT`信号。

每个信号有一个缺省动作，当用户进程没有给这个信号规定处理程序时，内核执行缺省动作。有以下几种缺省动作：

（1）异常终止（`abort`）。在当前目录生成一个`core`映像文件后，终止进程。它以后可以被调试工具使用。

（2）退出（`exit`）。不产生`core`映像文件就终止进程。

（3）忽略（`ignore`）。忽略该信号。

（4）停止（`stop`）。挂起进程。

（5）继续（`continue`）。如果进程挂起，则恢复进程运行，否则忽略该信号。

与`硬件中断`相类似，一个信号也可以被屏蔽。如果传送给进程的信号已经被进程所屏蔽，则该信号被记录在进程的待处理信号集合中。在清除屏蔽前，进程对信号不会采取任何动作。Linux对中断的屏蔽遵循POSIX的规范。

系统不允许进程屏蔽信号`SIGKILL`、`SIGSTOP/SIGCONT`。


## Linux系统中的信号

Linux系统用一些常用表示信号，如下表所示。信号定义在头文件`/usr/include/bits/signum.h`中。

![Linux系统中的信号](imgs/signum.jpeg)

详细说明如下：

- `SIGHUP`：当终端断连时，如果它的`CLOCAL`标识没有被置位，这个信号被传给`终端`的`控制进程`（主会话进程）。如果主会话进程已退出，则该信号被送给该会话的每一个进程组的主进程。大多数进程接收到`SIGHUP`后终止，因为它表示用户已不在。该信号常被用来通知`守护进程`去重读它们的配置文件。因为守护进程没有自己的控制终端，所以只有用这种方法通知它们。这个信号同其他的终端结束信号不一样，那些信号通常只送给前台进程组。
- `SIGINT`：当用户按下`Ctrl+c`等`中断键`时，该信号被送给`前台进程组`中`所有的进程`。它常被用来`中断当前进程`。
- `SIGQUIT`：当用户按下`Ctrl+\`等`退出键`时，该信号被送给前台进程组中所有的进程。
- `SIGTRAP`：当进程遇到一个断点时，该信号被传给进程。`SIGTRAP`常被设置断点的调试器使用。
- `SIGABRT`：进程通过系统调用`abort`向自己发送该信号。它的缺省动作是使进程异常终止。
- `SIGBUS`：当一个进程违反了除了存储保护以外的其他的硬件限制时，该信号被发送。
- `SIGFPE`：当出现`除0`错、浮点运算下溢时，该信号被发送。
- `SIGALRM`：进程用系统调用`alarm`设置定时报警器，当经过指定的时间后，系统将该信号发送给进程。
- `SIGTERM`：`kill`命令产生该信号，进程在收到它后，必需迅速退出。
- `SIGCLD/SIGCHLD`：当进程的一个子进程退出或停止时，系统向它发送这个信号。在该信号的处理函数里，可以调用`wait函数`，以避免子进程僵死。如果进程用`wait`等待它的子进程结束，可以忽略该信号。
- `SIGSTOP`：作业控制信号，使进程无条件地停止。该信号与`SIGKILL`信号是不能被忽略地两个信号。
- `SIGTSTP`：当用户按下`暂停键`（如`Ctrl+z`），这个信号被送给`前台进程组`中的`所有进程`。常用于`作业控制`中。
- `SIGTTIN`：当一个`后台进程`试图从它的控制终端`读`的时候，核心向它发送这个信号。常用于`作业控制`中。
- `SIGTTOU`：当一个`后台进程`试图向它的控制终端`写`的时候，核心向它发送这个信号。常用于`作业控制`中。
- `SIGURG`：当从`socket`收到带外数据时，该信号被发送。
- `SIGVTALRM`：进程调用`setitimer`设置定时器，当经过规定的时间后，核心向进程发送该信号。
- `SIGPROF`：统计`信息计时器`的`时间到期`。该信号常被`统计信息程序`使用，这种程序检查`别的进程`的`运行时`的特性。我们可以通过这种程序找到进程执行的瓶颈，再优化进程的执行。
- `SIGWINCH`：当终端和伪终端的窗口大小改变时，核心将该信号发给终端的前台进程所有的进程。该信号用于`X Window系统`中。
- `SIGPOLL/SIGIO`：`异步I/O事件`发生。
- `SIGPWR`：当系统检测到`电源`将要出现问题时，`电源管理的守护进程`把该信号发给`初始进程init`，使机器能在断电前完成正常关机的各种步骤。


## 对信号的处理

如果一个进程没有屏蔽某个`信号`，当核心向它发送信号时，`信号处理函数`被调用。在Linux中，有几种方法可以给信号设置处理函数。本章先介绍比较传统的处理方法，并分析它们有可能产生的问题，然后再介绍POSIX规范的信号处理。


### 设置信号处理函数

最简单的设置信号处理函数的方式是使用系统调用`signal`。它的原型如下：

```c

#include <signal.h>
void (* signal(int signum, void (* handler)(int))) (int)

```

说明：系统调用`signal`有两个参数，`signum`和`handler`。

`signum`是信号名，即上一个表格中的常量，`handler`是新的信号处理函数的指针，它有一个参数，即激活它的信号。

返回：系统调用`signal`返回原来的信号处理函数的指针。

在第一次调用时，`signal`的返回值是缺省的信号处理函数的指针，`SIG_IGN（忽略）`，`SIG_DFL（缺省）`、`SIG_ERR（错误）`。这三个常量也在`/usr/include/bits/signum.h`中定义。

```c
typedef void (* _ _ sighandler_t) (int)
#define	SIG_ERR	 ((_ _ sighandler_t) -1)	/* Error return.  */
#define	SIG_DFL	 ((_ _ sighandler_t)  0)	/* Default action.  */
#define	SIG_IGN	 ((_ _ sighandler_t)  1)	/* Ignore signal.  */

```

对比地，`Go语言`的`syscall`包内提供了如下内容：

```go

// `Signal`是描述进程信号的数值。它实现了`os.Signal`接口。
type Signal int

func (s Signal) Signal()
func (s Signal) String() string

```

`os`包内提供了如下内容：

```go

// `Signal`代表操作系统的信号。通常底层实现依赖于操作系统：在Unix系统上的实现即`syscall.Signal`。
type Signal interface {
    String() string
    Signal()        // 为了与其他字符串生成器进行区分
}

// ...
var (
    Interrupt Signal = syscall.SIGINT
    Kill Signal = syscall.SIGKILL
)

```

`os/signal`包内封装了`Go语言`里信号机制的一些使用API。详见源码文档。
