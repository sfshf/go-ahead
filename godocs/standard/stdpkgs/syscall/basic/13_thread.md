
# 多线程编程


## 概念


### 线程


#### 线程的概念

`线程`的一个简单的定义是：在`进程`的内部执行的`指令序列`。

这个定义是非常简单了。但是`线程的内涵`将在后面的叙述中逐步体现出来。

要解释线程必需从进程说起。一个`进程`是一个`复合的实体`，可以分为`两个部分`--`线程的集合`和`资源集合`。`线程`是一个`动态的对象`，它表示`进程`中的一个`控制点`，并且执行一系列的指令。`资源`包括`地址空间`、`打开的文件`、`用户凭证和配额`等等。这些资源为进程中所有线程所共享，存放在进程的有关数据结构中。此外每一个线程有自己的私有对象，比如`程序计数器`、`堆栈`和`寄存器上下文`。`传统的Unix进程`有一个单独的`控制线程`。在`多线程系统`中对这个概念进行了扩展，允许在一个进程中有`多于一个`的`控制线程`。

线程是一个非常抽象的概念，涉及传统的程序执行过程中的所有其他概念。

线程的应用是很广泛的。例如，在浏览器上就常常用到线程，在用户浏览某个网页的同时，实现该网页上的动画、播放音乐等等；在操作系统中也常常用一个线程来进行I/O操作以不影响主进程的执行。


#### 并发和并行

也许很多读者都已经了解了`并行`的概念。如果用户有一台计算机，用户在从某个Internet站点上用Netscape下在图片的同时，另外开了一个窗口在挖地雷，那么就可以说这台计算机上存在着两个`并行的程序`或者说两个`并行的进程`。在一台计算机中，`系统`可以通过开`多个进程`来达到`并行的目的`；而即使在同一个进程内，也可以通过开多个线程来达到并行的目的。每个线程都是独立执行该进程代码的不同的控制流。

这里简单介绍一下两个概念：`并行`和`并发`。`并发`是指若干个任务在某个时间段中都得到了执行，但`具体到每个时间片`，系统中都`只有一个任务在执行`--CPU在轮流执行各个任务或者说各个任务在分享CPU的时间片--`从宏观上看`，它似乎达到了`并行`的目的。而前面叙述中的`并行`只是一个模糊的说法。精确地说，`并行`就是指系统中有`多个CPU`，各个任务在同时被执行，即使在各个时间片上也是这样。


#### 内核线程与用户层线程

目前，有`三种`不同的`线程标准`，它们之间因操作系统的不同而异，各自在`Unix/Linux`、`Windows`、`OS/2`下有自己的`线程库`，分别称为`POSIX线程`、`Win32线程`和`OS/2线程`。后两种线程都不是通用的，仅能分别用于`Windows NT`、`Windows 9X`系列操作系统和`OS/2`操作系统中，而`POSIX线程`则是一种通用的标准（`IEEE 1003.1c`，`aka Pthreads`）和`VMS`一起都称为几乎所有Unix/Linux都具备的计算平台。

而根据实现方式的不同，线程则可以分为`内核线程`和`用户层线程`。它们完全可能提供一模一样的编程接口，但是这些接口函数却分别在`内核空间`和`用户空间`下实现。`Win32线程`和`OS/2线程`都属于`内核线程`，而`POSIX线程`则属于`用户层线程`。下面分别对这两种线程做详细介绍。


#### 内核线程

`内核线程`是由`操作系统提供`的`内核调用`实现的，需要操作系统提供`内核级别的支持`。

一个`内核线程的创建和撤销`是由`内核的内部需求`决定的，用来负责`执行一个指定的函数`。它共享`内核正文字段`和`全局数据`，`具有它自己的内核堆栈`。它`能够被单独地调度`并能使用`标准的内核同步机制`，如`sleep()`和`wakeup()`等。

`内核线程`对于执行`异步I/O操作`非常有用。内核可以简单地创`建一个新的线程`来处理这种请求，`而不是`提供一种特殊的机制，这些请求`被这些线程同步处理`，而`对于内核的其他部分出现异步`。内核线程也用来处理中断。

相对于进程来说，内核线程的创建和使用开销并不是很大。它们使用的唯一资源就是`内核堆栈`和在它们`不运行时`用来`保存寄存器上下文`的`一块内存区域`（同时也需要一些数据结构来保存状态和同步的信息）。`内核线程间的上下文切换`是很快的，因为不需要再次执行`内存映射`。

`内核线程`并`不是`一个专属于线程的概念。在`传统的Unix内核`中，系统进程如`页面管理守护进程（pagedaemon）`在功能上等同于`内核线程`。守护进程如`nfds`（Network File System Daemon网络文件系统服务器进程）`在用户层启动`，但是一旦启动，就完全在内核中运行。当它们进入到`内核态`后，`用户态上下文`就不需要了。它们也等同于`内核线程`。因为在`传统的系统`中`缺少`一种`单独的抽象概念`来代表`内核线程`，`多线程内核`允许`这些守护进程`作为`内核线程`来简单实现。在下面的叙述中读者将会看到，`轻量级进程LWP`就是通过`内核线程`来实现的。


#### 用户层线程

`内核线程的实现`离不开操作系统提供的内核支持（如`线程创建`、`同步`等）。但是`用户层线程`则不同，它是由`用户层的编码实现`的`自我完备`的`线程库`，所有的代码、数据结构都在`用户空间`里，`无需内核知道它们的存在`。用像`Mach的C-threads`和`POSIX的Pthreads`等线程库程序包都可以成功地实现。这些库提供所有的`创建`、`同步`、`调度`和`管理线程`的`函数`，而`不用`内核的特殊帮助。线程间的交互不包含内核的参与，因此速度非常快。

`用户层线程`有几个明显的优点，它以一个非常自然的方式来对向`Windows`那样的应用进行编程，`用户层线程`也通过把`异步操作`的复杂性隐藏在线程库中来提供`同步编程规范`。这就足以说明`用户线程`是十分有用的，甚至在`那种缺少任何支持线程的内核`的系统中，一个系统可以提供几个线程库，每一个都适用一个不同类的应用。

`用户层线程`的`最大优点`就是性能，`用户层线程`是`轻量级的`，`只有`当它们附着在`轻量级线程`上时才消耗内核资源，它们这种性能的获得是由于`功能的实现`是在`用户层`上，而不是使用`系统调用`，这样就避免了陷入`处理`和`跨越保护边界`时`移动参数和数据的开销`。一个非常有用的概念是`关键线程大小`，它指的是一个线程用作一个单独实体时必需做的工作量，这个大小取决于创建和使用一个线程的开销。对于`用户层线程`，它的重要部分的大小一般在`几百条指令左右`，`通过编译器的辅助`可以减少到`少于100条`。用户层线程需要非常少的时间去`创建`，`撤销`和`同步`。

另一方面，`用户层线程`也存在一些`局限性`，这主要是由于`内核`和`线程库`之间`信息的完全分离`造成的。因为`内核`不知道`用户层线程`的情况，这样它就`不能`使用它的`保护机制`来保护`用户层线程`不被`其他的线程`破坏。每一个进程拥有自己的`地址空间`，`内核`保护它们防止`其他授权的进程`的访问。`用户层线程`就`不享受这种保护`，它们在`公共地址空间`中操作。从线`程互相操作的要求`出发，`线程库`必需提供`同步的方法`。

由于`没有`内核显式地支持，`用户层线程`可能改善其`并发性`，但是`不能`增加其`并行性`，甚至在一个`多处理器的系统`中，一个`轻量级进程`（通过`内核线程`实现的）也是`不能`被`并行`执行的。

最后，本书只介绍`POSIX线程`--如前所述，它是`轻量级线程`。


### 进程、LWP和线程


#### 进程

`线程`和`进程`这两个概念是紧密联系着的，它们之间也有很多相同之处（例如`多线程`可以`并行`，`多进程`也可以`并行`；`进程`执行代码段中的代码，`线程`也是一样）；但另一方面，`线程`和`进程`的区别非常大，二者绝对不能划等号。

对于`Unix进程`的概念，一个经常被引用的答案是`进程是程序运行的一个实例`，但这个定义显然流于表面。研究一下进程的各种特征可得出，`进程`是一个运行`程序`并为其提供`执行环境`的`实体`。它包括一个`地址空间`和一个`控制点`。`进程`是`基本调度实体``任何时刻``只有一个`进程`在CPU上运行`。同时，进程`竞争并占用`各种`系统资源`，如`设备`和`内存`。它还`向系统请求服务`，由`内核`来`为其完成`。

每个`进程`都有`一个严格定义的上下文`，包括描述这个进程的所有信息。`上下文`由以下几个部分组成。

（1）`用户地址空间`。用户地址空间一般划分为几个部分--`程序正文（可执行代码）`、`数据`、`用户堆栈`、`共享内存区`等。

（2）`控制信息`。内核使用`两个数据结构`维护进程的控制信息--`u区`和`proc结构`。每个进程也有它自己的`内核堆栈`和`地址转换表`。

（3）`凭证`。`进程的凭证`包括与其相关的`用户ID`和`组ID`。

（4）`环境变量`。一些形如`variable=value`的字符串组，是从其父进程继承过来的。大多数Unix将其存放在`用户栈的栈底`。标准输入输出库提供对这些变量的增加、删除、更改以及将从变量中取值的函数。当调用一个新程序时，调用者用`exec`取得原始环境或提供一组新的变量。

（5）`硬件上下文`。硬件上下文包括`通用寄存器中的值`以及`一组特殊的系统寄存器`。`系统寄存器`包括：
- `程序计数器（PC）`，记录`将要执行的下一指令地址`。
- `堆栈指针（SP）`，包括`栈顶元素的地址`。
- `处理器状态字（PSW）`，包括几个表明`系统状态信息`的状态位，如当前和以前的`执行模`，当前和以前的`中断优先级`，`溢出位`和`进位位`。
- `内存管理寄存器`，对应进程的地址转换表。
- `浮点单元（FPU）寄存器`。

`程序寄存器`包括`当前正在运行进程的硬件上下文`。当发生上下文切换时，`寄存器中的值`都保存到`当前进程u区（称为进程控制块，PCB）`的特定部分。`内核`选择一个新进程运行时，将从`PCB`中`装载硬件上下文`。


#### 用户空间和系统空间

由于在`80286以上的CPU`中都`在指令级加上了用户权限的字段`以适应`多进程、多用户操作系统`的需求，相应地操作系统也就将CPU的操作分为了两种状态：`用户态`和`核心态`。一般情况下，`应用程序`总是运行在`用户态`下，这时`应用程序`可以自由地访问本进程所占用地各处空间（如`数据段`、`CPU寄存器`），`执行逻辑`和`算术操作`等等；但是，如果`应用程序`想要访问这以外的数据，例如它要`与别的进程共享的共享内存区`、`硬盘`和`网络上的数据`，那么就必需申请权限，因为这样的操作是核心态的，用户态下`不能`执行。在申请成功之后，CPU的控制权将从`应用程序`转交给`操作系统`，CPU就将从`用户态`切换到`核心态`，执行指定的操作（如读取硬盘等等）。等到操作结束，操作系统再从核心态切换回用户态，将CPU控制权交还给应用程序。而这样的核心态操作是不能随意让应用程序执行的，因此操作系统一般都会提供若干有限的操作--如打开、读取和关闭文件或设备、申请和读写共享内存区等等，以系统调用的形式，通过若干固定的函数接口让应用程序调用。这样一来，应用程序就只能执行某几个特定的核心操作，从而保证了系统的安全性。例如，在Linux中，`open`、`shmget`、`setgpid`等都是系统调用。应用程序不能直接地执行读取硬盘扇区、向网卡缓冲区和别地进程的空间中读写数据等核心态操作（除非有`root`权限），而必需通过这样的系统调用来实现由若干核心态操作组成的特定几个功能。

`系统调用`相对来说开销很大的操作，因为每个系统调用都需要`在两个模式间切换`，一个是在调用执行时，从用户态到核心态（这就叫`核心陷入`），另一个是在调用完成时返回到用户态（不妨称这种操作为`核心陷出`）。而`执行跨越内存保护边界的操作`需要花费多个CPU周期，如果这种操作频繁出现，将严重影响系统性能，因此应尽量使应用程序多在用户态下运行，少进行`核心陷入`，这就要求尽量少执行系统调用。

最后顺便指出，不仅系统调用需要很大的开销，在`用户空间`和`系统空间`之间进行数据拷贝（比方说，在一个用户层的应用程序要从网卡上读取数据时，数据就必需首先从网卡上被读到系统空间，再从系统空间被拷贝到用户空间），由于跨越了用户空间和系统空间的边界，也是开销非常大的操作。


#### 进程与线程的区别

`进程与线程的区别`主要表现在`数据结构`（线程的数据结构要比进程简单很多），`创建和切换`（线程的创建和切换开销远比进程的小）、`用户空间共享`（多个进程之间的地址不能互相访问，而同一个进程的多个线程可以）等几个方面。

##### 数据结构

每个进程的控制信息都保存两个数据结构中--`u区（用户区）`和`proc结构（也称为进程结构）`，在许多实现中，内核中有一个固定大小的`proc结构数组`，称为`proc表`。这个数组的大小严格地限制了任一时刻最多地进程数。较新地版本如`SVR4`允许动态分配`proc结构`，但是有一个大小固定的指向它们的指针数组。由于`proc结构`在系统空间中，尽管有时进程不在运行，这些结构在内核中也都是可见的。但是如前所述，一个进程不能访问系统空间，因此哪怕它要访问自己的`proc结构`，也必须通过系统调用（如得到本进程的进程ID就必需执行`getpid`系统调用，因为进程ID是存放在`proc结构`而不是`u区`中），付出`核心陷入`的代价。

`u区`或称`用户区`，是进程地址空间的一部分。即仅在进程运行时它才被映射且可见，许多实现中，`u区`总是被映射到每个进程虚拟空间的相同固定位置，内核只需简单地通过`变量u`进行访问（这一点可以在Linux地核心源代码中得到验证）。`上下文切换`地一个任务就是要重新建立这个映射，使内核中对`u`地引用指向新的`u区`的物理位置。

偶尔内核也要访问其他进程的`u区`。这是可能的，但只能间接地使用一组操作系统提供的核心调用来完成。这些在访问语义上的不同决定了什么信息应该存放在`proc结构`中，什么应该存放在`u区`中。`u区`中只包括那些在进程运行时才需要的数据。而`proc结构`中的信息可能在进程不运行时也需要。

`u区`中的主要域包括：

（1）进程控制块--保存进程不运行时硬件上下文。

（2）指向这个进程`proc结构`的指针。

（3）真实和有效UID和GID。

（4）当前系统调用的参数，返回值或错误状态。

（5）信号处理程序及相关信息。

（6）由程序的可执行文件头中获得的信息，如正文、数据、堆栈大小和其他内存管理信息。

（7）打开文件描述符表。现在的Unix系统如`SVR4`，可以按需要动态地扩展这张表。

（8）指向`当前目录的v节点`和`控制终端的指针`。`v节点`代表文件系统对象。

（9）CPU使用统计，概况统计信息，磁盘限量和资源限制信息。

（10）许多实现中，每个`进程的内核堆栈`是`u区`的一部分。

`proc结构`中的主要域如下：

（1）标识：每个进程有一个唯一的进程ID（PID）并属于一个特定的进程组。

（2）当前进程中`u区`的内核地址映射表位置。

（3）当前进程状态。

（4）在调度队列、阻塞队列或睡眠队列中的向前指针和向后指针。

（5）阻塞进程的睡眠通道。

（6）调度优先级和相关信息。

（7）信号处理信息：各种信号，包括忽略信号、阻塞信号、以发送信号及已处理信号的掩码。

（8）内存管理信息。

（9）将这个结构链接到活动进程，空闲进程或僵尸进程队列的指针。

（10）各种标识。

（11）将结构链接到基于PID的哈希队列（hash queue）中的指针。

（12）层次信息，描述进程与其他进程间的关系。

`proc结构`是进程与线程众多不同之处一个非常重要的方面--如前所述，进程拥有`proc结构`，存放在系统空间中；而线程则没有相应的存放于系统空间中的线程相关的数据结构。

下图是Unix进程结构示意图。

![Unix进程结构示意图](imgs/unixproc.jpeg)

与线程相比，进程是一个重负载、内核级的实体，而线程则是一个轻负载、用户层的实体。

如上所述，同一个进程的多个线程之间共享着进程的地址空间、文件描述符等数据结构，但各个线程也有自己私有的数据结构，这个数据结构在进程内部是唯一的而且仅仅在进程内部是可见的，包括：

- 线程号（Thread ID）。
- 寄存器状态（包括程序计数器和堆栈指针）。
- 堆栈。
- 信号屏蔽字（Signal mask）。
- 优先级（Priority）。
- 线程私有的存储段（Thread-private storage）。

线程的数据结构如下图所示。

![线程的数据结构](imgs/posixthread.jpeg)

可见，
